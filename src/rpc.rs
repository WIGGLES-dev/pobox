use crate::{actor::ActorRef, concurrency::Notify, disjoint::Disjoint};
use std::future::Future;

pub enum DispatchError<T>
where
    T: Dispatch,
{
    Killed,
    Paused(Notify),
    Locked(Notify),
    Moved { to: ActorRef<T> },
}

/// this trait represents a method that can be dispatched to a runner, this is generated by this crates
/// dispatch macro and generate ane num per method of an impl block
pub unsafe trait Dispatch: Sized {
    const ASYNC: bool;

    /// the state that a message is meant to be dispatched to. this is statically known and must implement
    /// the [Disjoint] trait. Since the state implements [Disjoint] the runner can coordinate safe mutable
    /// slices of state based on the incoming message that is [Dispatch]
    type State: Disjoint;

    /// a run method that is optimized for immutable borrowing
    fn run(self, state: &Self::State) -> Result<(), DispatchError<Self>>;
    /// a run method that is optimized for a mutable borrow of all state
    fn run_mut(self, state: &mut Self::State) -> Result<(), DispatchError<Self>>;

    /// async variant of run
    fn spawn(
        self,
        state: &Self::State,
    ) -> impl Future<Output = Result<(), DispatchError<Self>>> + Send
    where
        Self: Send,
        Self::State: Sync,
    {
        async move { Self::run(self, state) }
    }

    /// async variant of run mut
    fn spawn_mut(
        self,
        state: &mut Self::State,
    ) -> impl Future<Output = Result<(), DispatchError<Self>>> + Send
    where
        Self: Send,
        Self::State: Send,
    {
        async move { Self::run_mut(self, state) }
    }
}

pub trait IntoDispatch {
    type Dispatch;
    fn into_dispatch(self) -> Self::Dispatch;
}

/// a variant of Dispatch that pivots from a single channel receiving an enum, to many channels receiving struct
/// messages, where each struct maps to one method on an impl. This is useful for composing complicated actors
/// without incurring messaging overhead.
pub trait Fan {}
