use std::{cell::UnsafeCell, num::NonZeroUsize, ops::Deref};

use crate::{concurrency::Maildrop, rpc::Dispatch, runner::RunnerMessage};

pub trait Actor {
    type State;
    type Msg;
}

pub struct ActorCell<T> {
    pub(crate) value: UnsafeCell<T>,
}

impl<T> ActorCell<T> {
    pub fn new(value: T) -> Self {
        Self {
            value: UnsafeCell::new(value),
        }
    }
}

/// A message sink for a concrete message interface. The type T in [ActorRef] is meant to be derived
/// from this crates #[dispatch] macro, but may be generated by hand if that is useful. It has no
/// [crate::rpc::Dispatch] bounds by design.
///
/// It is important to note that an [ActorRef] is couply tied to the messaging patterns of this runtime.
/// We do this because we implement cooperative slicing of actor state from any arbitrary runner to cut
/// down on channel usage when you need to do high level coordination with mutable references of many actors.
/// This is inherently unsafe so you can't just plugin your own runner and assume its going to work.
pub struct ActorRef<T>
where
    T: Dispatch,
{
    /// not just an id, this is garunteed to be a valid memory address within the context of this
    /// crates cooperative aliasing features. if it is None, this [ActorRef] does not participate in
    /// the [RunnerMessage] contract and cannot be safely aliased.
    id: Option<NonZeroUsize>,
    /// the thing you'll be sending to. its just a channel, nothing fancy.
    sender: Maildrop<RunnerMessage<T>>,
}

impl<T> Clone for ActorRef<T>
where
    T: Dispatch,
{
    fn clone(&self) -> Self {
        Self {
            id: self.id,
            sender: self.sender.clone(),
        }
    }
}

impl<T> Deref for ActorRef<T>
where
    T: Dispatch,
{
    type Target = Maildrop<RunnerMessage<T>>;
    fn deref(&self) -> &Self::Target {
        &self.sender
    }
}
